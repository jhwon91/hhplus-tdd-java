# hhplus-tdd-java
🛳️ Test Driven Development

# 1. 목표

---

### `point` 패키지의 TODO 와 테스트코드를 작성해주세요.

**요구 사항**

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.

### `Default`

- `/point` 패키지 (디렉토리) 내에 `PointService` 기본 기능 작성
- `/database` 패키지의 구현체는 수정하지 않고, 이를 활용해 기능을 구현
- 각 기능에 대한 단위 테스트 작성

> 총 4가지 기본 기능 (포인트 조회, 포인트 충전/사용 내역 조회, 충전, 사용) 을 구현합니다.
>

### `Step 1`

- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
- 동시에 여러 요청이 들어오더라도 순서대로 (혹은 한번에 하나의 요청씩만) 제어될 수 있도록 리팩토링
- 동시성 제어에 대한 통합 테스트 작성



### `Step 2`

- 동시성 제어 방식에 대한 분석 및 보고서 작성 ( **README.md** )

---

# 2. 진행 방향성

## 📌 기본적인 기능 구현

- PointService 클래스에서 **포인트 충전**, **사용**, **조회**, **내역 조회** 기능을 구현했습니다.
- 각 API 엔드포인트는 PointController에서 구현하여  테스트 완료 하였습니다.

## 📌 정책 추가

- 잔고 부족 시 포인트 사용 실패를 처리하기 위한 로직을 추가할 예정입니다. 현재 useUserPoint 메서드에서 잔고 확인 후 예외를 발생시키도록 수정할 계획입니다.
- 포인트의 최대 충전 한도 및 기타 정책에 대한 추가적인 구현도 고려 중입니다.

## 📌 동시성 문제 해결

- 동시에 여러 건의 요청이 들어올 때 순차적으로 처리될 수 있도록 하기 위한 작업이 필요합니다.
- ~~이 부분에 대해 트랜잭션 관리와 synchronized 키워드를 사용할 계획입니다.~~
- synchronized 키워드는 한번에 한 함수만 실행 된다.<br>
  "공유자원"에 접근하고 있지 않다 -> **"같은 유저별" 요청끼리만 "동시에 수행되지 않게 해야 한다"**
- ConcurrentHashMap, ReentrantLock 키워드 확인
- 추가적인 동시성 제어 테스트를 통해 성능 및 무결성을 확인할 예정입니다.
### 📝 동시성과 순차성을 테스트하기 위한 시나리오
#### ✅ 동시에 여러 요청을 보냈을 때 데이터 일관성 확인
~~~
목표
    동시에 여러 사용자가 포인트 충전/사용 요청을 보냈을 때, 데이터 충돌 없이 정확하게 처리되는지 확인합니다.
시나리오
    1. 10명의 사용자가 동시에 포인트 충전 요청.
    2. 각 요청이 성공적으로 처리되었는지 확인합니다.
    3. 모든 요청이 끝난 후, 각 사용자의 포인트 잔액이 정상적으로 업데이트되었는지 확인합니다.
    4. 포인트가 누락되거나 중복 처리되지 않았는지 검증합니다.
예상 결과
    모든 사용자의 포인트 잔액이 정확하게 업데이트되어야 하며, 
    동일한 포인트가 중복으로 사용되거나 누락되지 않아야 합니다.
~~~
#### ✅ 동일한 사용자에 대한 동시 요청 처리
~~~
목표
    같은 사용자에 대한 동시 요청이 순차적으로 처리되어, 동시성 문제로 인해 잘못된 데이터가 저장되지 않는지 확인합니다.
시나리오
    1. 동일한 사용자에 대해 동시에 5개의 포인트 충전 요청.
    2. 충전 요청이 순차적으로 처리되어야 합니다. 첫 번째 충전이 완료된 후 두 번째 충전이 진행되어야 합니다.
    3. 모든 요청이 끝난 후, 해당 사용자의 최종 포인트 잔액을 확인합니다.
    4. 포인트가 중복 충전되거나 잘못된 금액으로 처리되지 않았는지 검증합니다.

예상 결과
    동시 요청에도 불구하고 포인트 충전은 순차적으로 처리되며, 최종 포인트 잔액이 정확히 계산되어야 합니다.
    요청이 충돌하지 않도록 락(lock) 또는 순차적 처리가 보장되어야 합니다.
~~~

#### ✅ 포인트 사용 시 잔액 부족 문제 확인
~~~
목표
    동시성 문제로 인해 사용자가 잔액보다 많은 포인트를 동시에 사용하려고 시도할 때, 정확하게 잔액 부족 오류가 발생하는지 확인합니다.
시나리오
    1. 한 사용자가 충분한 포인트 잔액을 가지고 있을 때, 동시에 2개의 포인트 사용 요청.
       ex) 잔액이 500 포인트일 때 2개의 300 포인트 사용 요청을 동시에 보냅니다.
    2. 두 요청 중 하나만 성공해야 하며, 다른 하나는 잔액 부족으로 인해 실패해야 합니다.
    3. 요청이 처리된 후 최종 잔액이 정확히 계산되었는지 확인합니다.
예상 결과
    • 첫 번째 요청이 성공적으로 처리되고, 두 번째 요청은 잔액 부족으로 인해 실패해야 합니다.
    • 최종 포인트 잔액은 200 포인트(500 - 300)가 되어야 합니다.
~~~
#### ✅ 포인트 충전/사용 요청 간의 순차 처리 확인
~~~
목표
    포인트 충전과 사용 요청이 동시에 들어올 때, 순서가 보장되어 정확하게 처리되는지 확인합니다.
시나리오
    1. 한 사용자가 동시에 포인트 충전과 포인트 사용 요청을 보냅니다.
       ex) 잔액이 200 포인트일 때 300 포인트 충전 요청과 250 포인트 사용 요청을 동시에 보냅니다.
    2. 시스템이 요청을 순차적으로 처리해야 합니다. 먼저 충전이 완료된 후, 사용 요청이 처리되어야 합니다.
    3. 최종 포인트 잔액을 확인하여, 두 요청이 순서대로 처리되었는지 검증합니다.
예상 결과
    • 충전 요청이 먼저 처리되어 잔액이 500 포인트로 증가한 후, 사용 요청이 처리되어 잔액이 250 포인트로 남아야 합니다.
    • 요청 처리 순서가 올바르게 보장되었는지 확인합니다.
~~~

#### ✅ 다수의 사용자가 동시에 포인트를 사용할 때 처리 성능 확인
~~~
목표:
    • 다수의 사용자가 동시에 포인트를 사용하거나 충전할 때 시스템의 성능이 유지되는지 확인합니다.
시나리오:
    1. 10명의 사용자가 동시에 포인트를 사용하거나 충전하는 요청을 보냅니다.
    2. 각 사용자의 요청이 동시에 처리되더라도 성능 저하나 데이터 일관성 문제가 발생하지 않는지 확인합니다.
    3. 최종적으로 각 사용자의 포인트 잔액을 확인합니다.
예상 결과:
    • 시스템이 많은 요청을 동시에 처리해도 성능 저하 없이 모든 요청이 정확하게 처리되어야 합니다.
    • 최종 잔액이 정확히 계산되고, 요청 처리 시간이 너무 오래 걸리지 않아야 합니다.
~~~

# 3. 진척도

## ✅ **완료된 작업**:

### PointService 구현

- **포인트 충전 기능** (chargeUserPoint) 완료
- **포인트 사용 기능** (useUserPoint) 완료 (잔고 부족 처리 필요)
- **포인트 조회 기능** (getUserPoint) 완료
- **포인트 내역 조회 기능** (getUserPointHistory) 완료
- **잔고 부족 시 포인트 사용 실패 처리**가 아직 반영 완료

### PointController 구현

- 각각의 API 엔드포인트 구현 완료
- 로그 기록을 통해 요청마다 사용자 ID 및 금액 정보 출력

## 🎈 **진행 중인 작업**

- **동시성 제어**를 위한 리팩토링 필요 (순차적 처리 및 테스트)

## ❌ **남은 작업**

- **동시성 문제 해결**: 여러 요청이 동시에 들어올 때 순차적으로 처리될 수 있도록 설계 수정
- **동시성 제어에 대한 통합 테스트** 작성
- **README 작성**: 동시성 제어 방식 및 사용된 기술에 대한 설명